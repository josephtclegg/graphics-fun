<!DOCTYPE html>
<html lang="en" style="text-align:center;">
<head>
	<meta charset="UTF-8">
	<title>im joe</title>
	<style>
	  canvas {
	    padding-left: 0;
	    padding-right: 0;
	    margin-left: auto;
	    margin-right: auto;
	    display: block;
	    width: 400px;
	    height: 400px;
	  }
	</style>
</head>
<body>
<h2><3<3<3<3<3</h2>

<script src="gl-matrix-min.js"></script>

<canvas id="canvas"></canvas>
<script>
	const vertexShaderSource = `
		attribute vec3 position;

		void main() {
		  gl_Position = vec4(position, 1.0);
		}
	`;
	const fragmentShaderSource = `
		precision highp float;
		uniform vec2 resolution;
		uniform float time;
		uniform vec2 rotation;

		void main() {
		  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);

		  vec2 center = vec2(0.5, 0.5);
		  vec2 st = gl_FragCoord.xy/resolution;
		  float radius = 0.2;

		  vec2 pos = vec2(
				      gl_FragCoord.x * rotation.y + gl_FragCoord.y * rotation.x,
				      gl_FragCoord.y * rotation.y - gl_FragCoord.x * rotation.x
				 );

		  if (distance(st, center) < radius) {
			gl_FragColor = vec4(sin(pos.y), cos(pos.x), cos(pos.y), sin(pos.x));
		  }

      gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
		}
	`;

	const date = new Date();
	const canvas = document.getElementById('canvas');
	const gl = canvas.getContext('webgl');

	//Create vertex shader
	const vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, vertexShaderSource);
	gl.compileShader(vertexShader);

	//Create fragment shader
	const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, fragmentShaderSource);
	gl.compileShader(fragmentShader);

	//Create shader program
	const shaderProgram = gl.createProgram();
	gl.attachShader(shaderProgram, vertexShader);
	gl.attachShader(shaderProgram, fragmentShader);
	gl.linkProgram(shaderProgram);
	gl.useProgram(shaderProgram);

	//Get attribute and uniform locations
	const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'position');
	const resolutionUniformLocation = gl.getUniformLocation(shaderProgram, 'resolution');
	const timeUniformLocation = gl.getUniformLocation(shaderProgram, 'time');
	const rotationLocation = gl.getUniformLocation(shaderProgram, 'rotation');

	//Create buffer
	const positionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  const positions = [
      0.420152, 0.078145, 0.904083,  //0
      0.995005,-0.091348, 0.040147,  //1
      0.518837, 0.835420, 0.181332,  //2
     -0.414682, 0.655962, 0.630676,  //3
     -0.515456,-0.381717, 0.767201,  //4
      0.355781,-0.843580, 0.402234,  //5
      0.414682,-0.655962,-0.630676,  //6
      0.515456, 0.381717,-0.767201,  //7
     -0.355781, 0.843580,-0.402234,  //8
     -0.995009, 0.091348,-0.040147,  //9
     -0.518837,-0.835420,-0.181332,  //10
     -0.420152,-0.078145,-0.904083   //11
  ];

  const indices = [
      0,11, 5,  //triangle 1
      0, 5, 1,  //triangle 2
      0, 1, 7,  //triangle 3
      0, 7,10,  //...
      0,10,11,
      1, 5, 9,
      5,11, 4,
     11,10, 2,
     10, 7, 6,
      7, 1, 8,
      3, 9, 4,
      3, 4, 2,
      3, 2, 6,
      3, 6, 8,
      3, 8, 9,
      4, 9, 5,
      2, 4,11,
      6, 2,10,
      8, 6, 7,
      9, 8, 1   //triangle 20
  ];

  var vertices = [];

  for (var i = 0; i < indices.length; i+=3) {
    //its 3*indices[i] because each 'position' has 3 values xyz so we need the right stride
    for (var j = 0; j < 3; j++) {
      //the three 'vertices.push' statements in this loop are pushing the 3 coordinates of one
      //vertex to the array, so to tesselate a triangle-at-a-time we need the inner loop to do
      //all three of the triangle's vertices, hence the bound 0 <= j < 3
      let index = 3*indices[i+j];
      vertices.push(positions[index]);
      vertices.push(positions[index+1]);
      vertices.push(positions[index+2]);
    }
  }
  for (var i = 0; i < vertices.length; i++) {
    console.log(vertices[i]);
  }
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

	//Set attributes
	gl.enableVertexAttribArray(positionAttributeLocation);
	gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

	//Set uniforms
	gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);

	function render() {
		gl.uniform1f(timeUniformLocation, performance.now() / 1000);
		gl.uniform2fv(rotationLocation, [performance.now()/1000, performance.now()/1000]);
		gl.drawArrays(gl.LINE_LOOP/* TRIANGLES */, 0, 60); //20 triangles, 3 vertices each
		requestAnimationFrame(render);
	}

	render();
</script>
wooow that's prettY!!!
</body>
</html>
